# Sección 05: Operators

---

## Operador - Handle

Es un operador avanzado que permite combinar la funcionalidad de los operadores `map()` y `filter()`. Te permite
transformar, filtrar o descartar elementos dentro de un `Publisher` (como un `Flux` o un `Mono`), lo que lo hace muy
versátil.

La firma del método es:

````java
public final <V> Flux<V> handle(BiConsumer<? super T, SynchronousSink<V>> handler)
````

- `T` es el tipo de los elementos que se están procesando en el `Flux`.
- `V` es el tipo de los elementos que producirá después de la operación de `handle()`.
- `SynchronousSink<V>` es un callback que te permite emitir elementos de forma síncrona, permitiéndote transformar o
  filtrar el flujo de datos.

**¿Qué puedes hacer con handle()?**

1. Transformar elementos: Puedes modificar o transformar los elementos en el flujo.
2. Filtrar elementos: Al no emitir un valor en el SynchronousSink, puedes descartar elementos del flujo.
3. Emitir múltiples elementos: Puedes emitir más de un elemento o no emitir ninguno.

````java

/**
 * Con el operador .handle() cumplamos los siguientes criterios
 * 1 => -2
 * 4 => no enviarlo
 * 7 => error
 * En los otros casos => enviarlos
 */
public class Lec01Handle {
    public static void main(String[] args) {
        Flux.range(1, 10)
                .filter(i -> i != 7)
                .handle((item, synchronousSink) -> {
                    switch (item) {
                        case 1 -> synchronousSink.next(-2);
                        case 4 -> {
                        }
                        case 7 -> synchronousSink.error(new RuntimeException("Valor 7, lanzando error"));
                        default -> synchronousSink.next(item);
                    }
                })
                .subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: -2
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 5
//d.m.a.common.DefaultSubscriber :  recibido: 6
//d.m.a.common.DefaultSubscriber :  recibido: 8
//d.m.a.common.DefaultSubscriber :  recibido: 9
//d.m.a.common.DefaultSubscriber :  recibido: 10
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

Este ejemplo destaca cómo puedes usar `.handle()` para realizar múltiples operaciones de transformación y filtrado
dentro de una única operación. La lógica que se muestra permite manipular de manera condicional ciertos valores y
aplicar transformaciones, como emitir `-2` en lugar de `1`, filtrar el `4` y manejar potenciales `errores` (aunque en
este caso no se alcanzaría el error por el filter inicial).

## Operator - Handle Assignment

````java
public class Lec02HandleUntilAssignment {
    public static void main(String[] args) {
        // Este flujo (generate) está generando nombres de países de manera infinita.
        Flux<String> generate = Flux.generate(synchronousSink -> {
            synchronousSink.next(Util.faker().country().name());
        });

        // En resumen, este bloque de código está manipulando el flujo para que continúe 
        // emitiendo nombres de países hasta que aparezca "Peru". Una vez que eso sucede, el flujo se termina.
        Flux<String> handle = generate.handle((countryName, synchronousSink) -> {
            synchronousSink.next(countryName);
            if (countryName.equalsIgnoreCase("Peru")) {
                synchronousSink.complete();
            }
        });

        handle.subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: Malta
//d.m.a.common.DefaultSubscriber :  recibido: Korea, Republic of
//d.m.a.common.DefaultSubscriber :  recibido: Ukraine
//d.m.a.common.DefaultSubscriber :  recibido: Iceland
//d.m.a.common.DefaultSubscriber :  recibido: China
//d.m.a.common.DefaultSubscriber :  recibido: Costa Rica
//...
//d.m.a.common.DefaultSubscriber :  recibido: Iran (Islamic Republic of)
//d.m.a.common.DefaultSubscriber :  recibido: Turkmenistan
//d.m.a.common.DefaultSubscriber :  recibido: Cyprus
//d.m.a.common.DefaultSubscriber :  recibido: Estonia
//d.m.a.common.DefaultSubscriber :  recibido: Peru
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

- `Flux.generate()` es una forma de generar elementos de forma síncrona, uno por uno. Aquí, se está creando un Flux que
  genera nombres de países de manera indefinida utilizando Util.faker().country().name(). Esto simula una fuente
  continua de datos que emite un nuevo nombre de país cada vez que se solicita.

- `synchronousSink.next(...)`: Este es el mecanismo que se usa para emitir el nombre del país generado en cada
  iteración.

- El operador `.handle()` toma el flujo generado (generate) y lo manipula.

- `countryName`: Representa el nombre del país que ha sido emitido por el flujo.

-`synchronousSink.next(countryName)`: Vuelve a emitir el nombre del país sin cambios. Esto permite que el flujo continúe
emitiendo los nombres generados.

- Condicional con if `(countryName.equalsIgnoreCase("Peru"))`: Si el nombre del país es `Peru`, el flujo se completa
  llamando a `synchronousSink.complete()`. Esto significa que tan pronto como aparezca `Peru` en el flujo, el `Flux`
  detendrá su emisión y completará la secuencia.

## Do Hooks/Callbacks

Los operadores de la familia do... (como `doOnNext`, `doFirst`, `doComplete`, etc.) se utilizan para agregar acciones
secundarias o efectos secundarios en un flujo reactivo. A diferencia de operadores como `map()` o `filter()`, no
modifican el flujo de datos, sino que te permiten ejecutar lógica adicional en momentos específicos del ciclo de vida
de un `Publisher` (como `Flux` o `Mono`).

````java
  public static void main(String[] args) {
    Flux.<Integer>create(fluxSink -> {
                log.info("Inicia el productor");
                for (int i = 0; i < 4; i++) {
                    fluxSink.next(i);
                }
                fluxSink.complete();
//                     fluxSink.error(new RuntimeException("oops"));
                log.info("Finaliza el productor");
            })
            .doOnComplete(() -> log.info("doOnComplete"))
            .doFirst(() -> log.info("doFirst"))
            .doOnNext(item -> log.info("doOnNext: {}", item))
            .doOnSubscribe(subscription -> log.info("doOnSubscribe: {}", subscription))
            .doOnRequest(request -> log.info("doOnRequest: {}", request))
            .doOnError(error -> log.info("doOnError: {}", error.getMessage()))
            .doOnTerminate(() -> log.info("doOnTerminate")) // complete or error case
            .doOnCancel(() -> log.info("doOnCancel"))
            .doOnDiscard(Object.class, o -> log.info("doOnDiscard: {}", o))
            .doFinally(signal -> log.info("doFinally: {}", signal)) // finally irrespective of the reason
            .subscribe(Util.subscriber("subscriber"));
}
//d.m.a.o.Lec03DoCallbacks       : doFirst
//d.m.a.o.Lec03DoCallbacks       : doOnSubscribe: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@5fbe4146
//d.m.a.o.Lec03DoCallbacks       : doOnRequest: 9223372036854775807
//d.m.a.o.Lec03DoCallbacks       : Inicia el productor
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 0
//d.m.a.common.DefaultSubscriber : subscriber recibido: 0
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 1
//d.m.a.common.DefaultSubscriber : subscriber recibido: 1
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 2
//d.m.a.common.DefaultSubscriber : subscriber recibido: 2
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 3
//d.m.a.common.DefaultSubscriber : subscriber recibido: 3
//d.m.a.o.Lec03DoCallbacks       : doOnComplete
//d.m.a.o.Lec03DoCallbacks       : doOnTerminate
//d.m.a.common.DefaultSubscriber : subscriber ¡completado!
//d.m.a.o.Lec03DoCallbacks       : doFinally: onComplete
//d.m.a.o.Lec03DoCallbacks       : Finaliza el productor
````

## Operador - doOnNext - Aclaración

El operador doOnNext en Project Reactor se utiliza para ejecutar una acción secundaria cada vez que el flujo (Mono o
Flux) emite un elemento. Este operador es parte de la familia de operadores do..., que permiten agregar efectos
secundarios (side effects) sin modificar los datos del flujo.

- La inmutabilidad es buena, pero no significa que la mutación sea mala.
- La `programación funcional` prefiere las` funciones puras` (sin efectos secundarios).
    - Deberíamos preferir las funciones puras.

Veamos el siguiente ejemplo.

````java
public class CustomerServiceImpl implements CustomerService {

    @Override
    public Mono<Customer> updateCustomer() {
        return this.repository.findById(123)
                .doOnNext(customer -> customer.setAge(10))
                .flatMap(this.repository::save);
    }

}
````

Estamos trabajando con una entidad `Customer`. Nuestras entidades son objetos `mutables`. En el código anterior estamos
obteniendo un usuario de la base de datos a través de su identificador, esto nos retorna un `Mono<Customer>`, por lo
que no sabemos cuándo obtendremos el objeto `Customer`. En ese sentido, como queremos actualizar el valor de la edad
del objeto buscado, necesitamos utilizar el operador `doOnNext` para realizar esa operación. El `Project Reactor`
proporciona ciertas garantías de que se sincronizará internamente cuando realizamos la mutación `customer.setAge(10)`,
esto lo hace un hilo y ningún otro hilo vendrá y lo cambiará.

## Operador - Delay Elements

Retrasar cada uno de los elementos de `Flux` (señales Subscriber. `onNext`) durante una duración determinada. Las
señales se retrasan y continúan en el Scheduler predeterminado paralelo, pero las secuencias vacías o las señales de
error inmediato no se retrasan.

El operador `delayElements()` en Project Reactor introduce un retraso entre la emisión de cada elemento en un `Flux`.
Su propósito es emitir los elementos con una demora específica sin bloquear el hilo en el que se está ejecutando, lo
que lo hace ideal para escenarios reactivos.

````java
public class Lec04Delay {
    public static void main(String[] args) {
        /**
         * El Delay Element se aplicará en un hilo separado
         */
        Flux.range(1, 5)
                .delayElements(Duration.ofSeconds(1))
                .subscribe(Util.subscriber());

        /**
         * Bloqueamos el hilo principal para ver los valores que se están emitiendo
         */
        Util.sleepSeconds(11);
    }
}
````

En el ejemplo anterior, se emitirá un número cada segundo. Internamente, `delayElements()` trabaja utilizando un
`Scheduler`, permitiendo que los elementos se emitan sin bloquear el hilo principal.

Ahora, solo para este ejemplo, como nos interesa ver cómo se van emitiendo los valores, necesitamos bloquear el hilo
principal utilizando `Thread.sleep` para evitar que el programa termine antes de que se emitan todos los elementos.

## doOnNext, doOnError y doOnComplete

En este curso hemos estado usando el método estático `Util.subscriber()` para mostrar la información que emite los flux.
Recordemos que este método nos retorna una implementación propia que creamos del `Subscriber`, donde implementamos los
métodos `onNext`, `onError` y `onComplete`.

En algunos casos, convendría hacer uso de de los operadores `.doOnNext()`, `.doOnError()` o `.doOnComplete()`, tal como
se ve en el siguiente ejemplo:

````java
public class Lec05Subscribe {

    private static final Logger log = LoggerFactory.getLogger(Lec05Subscribe.class);

    public static void main(String[] args) {
        Flux.range(1, 10)
                .doOnNext(number -> log.info("recibido: {}", number))
                .doOnError(err -> log.error("error", err))
                .doOnComplete(() -> log.info("Completado"))
                .subscribe();
    }
}
````

## Error Handling - onErrorReturn

Supongamos que tenemos el siguiente ejemplo, donde se emiten números y cuando el número emitido sea 5 lo dividimos entre
cero, eso nos dará un error, así que veamos el comportamiento.

````java
public static void main(String[] args) {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  error: / by zero
````

Para solucionar ese error, podemos utilizar el operador `.onErrorReturn()` para devolver un valor predeterminado
en caso ocurra un error similar al ejemplo anterior.

El operador `onErrorReturn()` emite un valor de respaldo capturado cuando se observe algún error en el flux.
El operador `onErrorReturn()` de `Project Reactor` finaliza el flujo después de devolver el valor especificado cuando
ocurre un error. Es decir, una vez que se captura una excepción y se emite el valor de retorno, el flujo se completa,
aunque queden más elementos por emitir.

````java
public static void main(String[] args) {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .onErrorReturn(-1)
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: -1
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

**Importante**

> Es importante la ubicación del operador `.onErrorReturn()`, por lo general podríamos colocarlo casi al final para
> que esté pendiente de todo el flujo.

Ahora, supongamos que queremos retornar un valor en caso de una excepción, pero siempre y cuando sea en función de una
excepción específica. Por ejemplo, si ocurre la excepción `IllegalArgumentException`, solo en ese caso se emitirá como
valor de retorno el `-1`.

````java
private static void onErrorReturn2() {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .onErrorReturn(IllegalArgumentException.class, -1)
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  error: / by zero
````

En el ejemplo anterior, estamos recibiendo el error y finalizando el flux, dado que en el operador `onErrorResume()`
esperábamos un error del tipo `IllegalArgumentException` para retornar un `-1`, pero el error que obtuvimos fue
del tipo `ArithmeticException`, es por eso que se continuó propagando el error hasta el `subscribe`.

Podemos agrega tantos operadores `onErrorReturn` como quisiéramos especificando la excepción que se debe lanzar para
poder retornar un determinado valor.

````java
private static void onErrorReturn2() {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .onErrorReturn(IllegalArgumentException.class, -1)
            .onErrorReturn(ArithmeticException.class, -2)
            .onErrorReturn(-3) // En caso de cualquier otra excepción se retornará -3
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: -2
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Error Handling - onErrorResume

En la sección anterior donde usámos el operador `onErrorReturn()` vimos que podemos retornar un valor previamente
definido, un valor en código duro, pero qué pasa si queremos calcular el valor, en este escenario `Reactor` nos
proporciona otro operador `onErrorResume()`.

El operador `onErrorResume()` en `Project Reactor` es una forma de manejar errores de manera más flexible que
`onErrorReturn()`. Mientras que `onErrorReturn()` devuelve un valor específico cuando ocurre un error y luego
completa el flujo, `onErrorResume()` permite continuar el flujo a partir de una nueva fuente `(Publisher)` cuando
ocurre una excepción.

Entonces, cuando el flujo original encuentra un error, `onErrorResume()` te permite manejar ese error y continuar
emitiendo elementos desde otro `Flux o Mono`. En lugar de simplemente devolver un valor de `fallback`, puedes decidir
qué hacer en función del tipo o contenido del error.

````java

public class Lec06ErrorHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        Flux.range(1, 10)
                .map(number -> number == 5 ? 5 / 0 : number) //intencional
                .onErrorResume(throwable -> fallback())
                .subscribe(Util.subscriber());
    }

    // Imaginemos que es un servicio alternativo
    private static Mono<Integer> fallback() {
        return Mono.fromSupplier(() -> Util.faker().random().nextInt(10, 100));
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: 48
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

En el siguiente ejemplo, observamos que luego que ocurre el error, el operador `onErrorResume()` entra en acción, se
llama al método `fallback2()` y se empieza a emitir un nuevo flux.

````java

public class Lec06ErrorHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorResume2();
    }

    private static Flux<Integer> fallback2() {
        return Flux.range(50, 5);
    }

    private static void onErrorResume2() {
        Flux.range(1, 10)
                .map(number -> number == 5 ? 5 / 0 : number) //intencional
                .onErrorResume(throwable -> fallback2())
                .subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: 50
//d.m.a.common.DefaultSubscriber :  recibido: 51
//d.m.a.common.DefaultSubscriber :  recibido: 52
//d.m.a.common.DefaultSubscriber :  recibido: 53
//d.m.a.common.DefaultSubscriber :  recibido: 54
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

En el siguiente ejemplo supongamos que el flux emite un error del tipo `RuntimeException`, entonces el primer operador
`onErrorResume()` está esperando un tipo `ArithmeticException` para ejecutar el `fallback1()`, pero como la excepción
es del tipo `RuntimeException`, se pasa al siguiente operador `onErrorResume()` quien ejecuta el `fallback3()`. Ahora,
esperaríamos que el `fallback3()` emita elementos, pero intencionalmente estamos emitiendo un error, suponiendo que
algo falló en dicho método. Entonces, el flujo continuará hacia el operador `onErrorReturn()` donde finalmente se
lanzará el valor `-5`.

````java

public class Lec06ErrorHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorResume3();
    }

    private static void onErrorResume3() {
        Flux.error(new RuntimeException("Oops"))
                .onErrorResume(ArithmeticException.class, e -> fallback1())
                .onErrorResume(throwable -> fallback3())
                .onErrorReturn(-5)
                .subscribe(Util.subscriber());
    }

    private static Mono<Integer> fallback1() {
        return Mono.fromSupplier(() -> Util.faker().random().nextInt(10, 100));
    }

    private static Flux<Integer> fallback3() {
        return Flux.error(new IllegalArgumentException("Ocurrió un error"));
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: -5
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Error Handling - onErrorComplete

Simplemente, complete la secuencia reemplazando una señal `onError` con una señal `onComplete`. Todas las demás señales
se propagan tal como están.

````java
private static void onErrorComplete1() {
    Mono.error(new RuntimeException("Oops"))
            .onErrorComplete()
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Error Handling - onErrorContinue

El operador `onErrorContinue()` en Project Reactor permite que el flujo continúe emitiendo elementos después de
encontrar un error, omitiendo los elementos problemáticos sin detener todo el flujo. A diferencia de operadores como
`onErrorReturn()` o `onErrorResume()`, que manejan el error y completan el flujo o lo reemplazan por una nueva
secuencia, `onErrorContinue()` simplemente omite el error y continúa con los siguientes elementos.

Permita que los operadores compatibles se recuperen de los errores eliminando el elemento incriminatorio de la secuencia
y continuando con los elementos subsiguientes. El error recuperado y el valor asociado se notifican a través del
BiConsumer proporcionado. Alternativamente, al lanzar desde ese biconsumer se propagará la excepción lanzada en sentido
descendente en lugar del error original, que se agrega como una excepción suprimida a la nueva.

Cuando un error ocurre en un elemento del flujo, `onErrorContinue()` permite saltarse ese error y continuar procesando
los elementos restantes. Además, te permite acceder tanto al error como al elemento que causó el problema para manejar
el error de forma personalizada, pero sin detener la emisión de otros elementos.

````java
private static void onErrorContinue() {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .onErrorContinue((throwable, o) -> {
                log.error("Error:", throwable);
                log.error("Elemento que causó el problema: {}", o);
            })
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.s.Lec06ErrorHandling     : Error:
//java.lang.ArithmeticException: / by zero
//16:43:09.735 ERROR [           main] d.m.a.s.Lec06ErrorHandling     : Elemento que causó el problema: 5
//16:43:09.735 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6
//16:43:09.736 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 7
//16:43:09.736 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 8
//16:43:09.736 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 9
//16:43:09.736 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 10
//16:43:09.736 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
//Process finished with exit code 0
````

## Operador - DefaultIfEmpty

Proporciona un valor único predeterminado si esta secuencia se completa sin ningún dato.

El operador `defaultIfEmpty()` en Project Reactor se usa para emitir un valor por defecto cuando un `Mono` o `Flux` no
emite ningún elemento. Si el flujo es `vacío`, `defaultIfEmpty()` permite proporcionar un valor alternativo en lugar de
completar el flujo sin emitir nada.

El operador `defaultIfEmpty()` se utiliza principalmente para valores `hardcodeados` o `predefinidos`, es decir,
valores que ya conoces y que especificas directamente cuando invocas el operador. El valor que se emite cuando el
flujo está vacío debe estar definido en el momento de usar `defaultIfEmpty()`.

````java
public class Lec07DefaultIfEmpty {
    public static void main(String[] args) {
        Flux.empty()
                .defaultIfEmpty("fallback")
                .subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: fallback
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Operador - Switch If Empty

Cambie a un `Publisher` alternativo si la secuencia se completa sin ningún dato.

El operador `switchIfEmpty()` en Project Reactor es similar a `defaultIfEmpty()`, pero ofrece más flexibilidad.
Mientras que `defaultIfEmpty()` solo emite un valor `hardcodeado` cuando un flujo está vacío, `switchIfEmpty()`
permite sustituir el flujo vacío por otro `Publisher` (otro `Flux` o `Mono`). Esto lo hace útil cuando necesitas
reaccionar dinámicamente si no se emite ningún valor.

Cuando el flujo original no emite ningún valor, `switchIfEmpty()` permite `cambiar` a otro flujo (otro `Flux` o `Mono`)
y continuar la emisión desde esa nueva fuente.

````java
public class Lec08SwitchIfEmpty {
    public static void main(String[] args) {
        Flux.range(1, 10)
                .filter(number -> number > 11)
                .switchIfEmpty(fallback())
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> fallback() {
        return Flux.range(100, 3);
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: 100
//d.m.a.common.DefaultSubscriber :  recibido: 101
//d.m.a.common.DefaultSubscriber :  recibido: 102
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Operador - Timeout

En el siguiente ejemplo `timeout(Duration.ofSeconds(1))`, esperará como máximo 1 segundo (tiempo definido en el timeout)
a que el Publisher del método `getProductName()` retorne un valor. En caso transcurra el segundo y no haya respuesta, el
operador `timeout()` propagará la excepción `TimeoutException`.

````java
public class Lec09Timeout {
    public static void main(String[] args) {
        getProductName()
                .timeout(Duration.ofSeconds(1))
                .subscribe(Util.subscriber());

        Util.sleepSeconds(5);
    }

    private static Mono<String> getProductName() {
        return Mono.fromSupplier(() -> Util.faker().commerce().productName())
                .delayElement(Duration.ofMillis(3000));
    }
}
//d.m.a.common.DefaultSubscriber :  error: Did not observe any item or terminal signal within 1000ms in 'delayElement' (and no fallback has been configured)
````

La excepción que se genera tiene la siguiente respuesta **"No se observó ningún elemento ni señal de terminal dentro
de los 1000 ms en 'delayElement' (y no se ha configurado ninguna alternativa)".**

Podemos hacer caso al mensaje anterior y definir un operador que nos retorne una respuesta alternativa al producirse el
error. En este caso usaremos el `onErrorReturn()` para retornar un String.

````java
public class Lec09Timeout {
    public static void main(String[] args) {
        getProductName()
                .timeout(Duration.ofSeconds(1)) //Como máximo esperará 1s a que el Publisher retorne el valor
                .onErrorReturn("fallback")
                .subscribe(Util.subscriber());

        Util.sleepSeconds(5);
    }

    private static Mono<String> getProductName() {
        return Mono.fromSupplier(() -> Util.faker().commerce().productName())
                .delayElement(Duration.ofMillis(3000));
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: fallback
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

Ahora, qué pasa si el publisher envía los datos dentro del tiempo máximo que hemos definido como timeout, es decir,
como máximo esperaremos 1 segundo para recibir la respuesta. El publisher enviará la respuesta en un tiempo de
`900ms`, eso cumpliría la condición del timeout, así que el flujo se ejecutaría sin problemas.

````java
public class Lec09Timeout {
    public static void main(String[] args) {
        getProductName()
                .timeout(Duration.ofSeconds(1)) //Como máximo esperará 1s a que el Publisher retorne el valor
                .onErrorReturn("fallback")
                .subscribe(Util.subscriber());

        Util.sleepSeconds(5);
    }

    private static Mono<String> getProductName() {
        return Mono.fromSupplier(() -> Util.faker().commerce().productName())
                .delayElement(Duration.ofMillis(900));
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: Sleek Cotton Wallet
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

En el propio `timeout()` existe la alternativa de poder usar un nuevo publisher si es que se vence el tiempo definido,
de esa manera nos evitamos usar el operador `onErrorResume` si es que quisiéramos llamar a otro servicio.

En el siguiente ejemplo, definimos un `timeout` de 1s de espera, en caso transcurra más de 1s, se llamará al `fallback`
definido como segundo parámetro.

Tal cual tenemos el código, si el `timeout` llama al método `fallback()` allí no interesa el tiempo que se demore, es
decir, la evaluación del `timeout` de 1 segundo es para el `getProductName()`.

````java
public class Lec09Timeout {
    public static void main(String[] args) {
        getProductName()
                .timeout(Duration.ofSeconds(1), fallback())
                .subscribe(Util.subscriber());

        Util.sleepSeconds(5);
    }

    private static Mono<String> getProductName() {
        return Mono.fromSupplier(() -> "service-" + Util.faker().commerce().productName())
                .delayElement(Duration.ofMillis(2000));
    }

    private static Mono<String> fallback() {
        return Mono.fromSupplier(() -> "fallback-" + Util.faker().commerce().productName())
                .delayElement(Duration.ofMillis(3000));
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: fallback-Small Aluminum Shoes
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Operador - Transform

Este operador nos ayudará a escribir código reutilizable en el pipeline reactivo que construyamos.

Veamos el siguiente ejemplo donde estamos repitiendo varias veces los métodos `doOnNext`, `doOnError` y `doOnComplete`.
**¿Habrá alguna manera de poder reutilizar el código repetitivo?**

````java

public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    record Customer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }

    public static void main(String[] args) {
        getCustomers()
                .doOnNext(customer -> log.info("recibido: {}", customer))
                .doOnError(throwable -> log.error("error", throwable))
                .doOnComplete(() -> log.info("Completado"))
                .subscribe();

        getPurchaseOrders()
                .doOnNext(purchaseOrder -> log.info("recibido: {}", purchaseOrder))
                .doOnError(throwable -> log.error("error", throwable))
                .doOnComplete(() -> log.info("Completado"))
                .subscribe();
    }

    private static Flux<Customer> getCustomers() {
        return Flux.range(1, 3)
                .map(number -> new Customer(number, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(number -> new PurchaseOrder(Util.faker().commerce().productName(), number, number * 10));
    }
}
//d.m.a.s.Lec10Transform         : recibido: Customer[id=1, name=Doretta]
//d.m.a.s.Lec10Transform         : recibido: Customer[id=2, name=Vonda]
//d.m.a.s.Lec10Transform         : recibido: Customer[id=3, name=Garland]
//d.m.a.s.Lec10Transform         : Completado
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Fantastic Copper Chair, price=1, quantity=10]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Rustic Wooden Hat, price=2, quantity=20]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Mediocre Wooden Plate, price=3, quantity=30]
//d.m.a.s.Lec10Transform         : Completado
````

Para reutilizar código en programación reactiva, podemos utilizar el operador `transform()`, en este caso, podríamos
hacerlo de la siguiente manera.

````java

public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    record Customer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }

    public static void main(String[] args) {
        getCustomers()
                .transform(addDebugger())
                .subscribe();

        getPurchaseOrders()
                .transform(addDebugger())
                .subscribe();
    }

    private static Flux<Customer> getCustomers() {
        return Flux.range(1, 3)
                .map(number -> new Customer(number, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(number -> new PurchaseOrder(Util.faker().commerce().productName(), number, number * 10));
    }

    /**
     * Obtenemos un flujo, añadimos los operadores y devolvemos el flujo
     */
    private static <T> Function<Flux<T>, Flux<T>> addDebugger() {
        return flux -> flux
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error("error", throwable))
                .doOnComplete(() -> log.info("Completado"));
    }
}
//d.m.a.s.Lec10Transform         : recibido: Customer[id=1, name=Camille]
//d.m.a.s.Lec10Transform         : recibido: Customer[id=2, name=Hee]
//d.m.a.s.Lec10Transform         : recibido: Customer[id=3, name=Santiago]
//d.m.a.s.Lec10Transform         : Completado
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Synergistic Bronze Shoes, price=1, quantity=10]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Ergonomic Copper Chair, price=2, quantity=20]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Enormous Linen Lamp, price=3, quantity=30]
//d.m.a.s.Lec10Transform         : Completado
````

El operador `transform()` en Project Reactor permite transformar un flujo (`Flux` o `Mono`) utilizando una función. Es
una forma de aplicar una serie de operadores a un flujo dentro de una operación de transformación reutilizable. El
objetivo principal de `transform()` es permitir la composición de operadores en un solo paso.

`transform`: Es una función que recibe un `Flux<T>` y devuelve un nuevo `Publisher<V>`. Dentro de esta función puedes
aplicar cualquier transformación o conjunto de operadores al flujo original.

Con el operador `transform()` podemos evitar duplicación de código. Si aplicas la misma serie de operadores en varios
lugares de tu código, puedes encapsular esa lógica en una función y usar `transform()` para aplicarla de manera
consistente en diferentes flujos.

### Sobre la función creada

En el código anterior hemos creado el método genérico `addDebugger()`, este método retorna una función que toma un
`Flux<T>` como entrada y retorna un `Flux<T>` como salida. En otras palabras, se recibe un `flux` y se retorna el
mismo `flux`.

El método toma un `Flux<T>` y aplica varios operadores como `doOnNext()`, `doOnError()`, y `doOnComplete()` para añadir
acciones de depuración.

La salida es otro `Flux<T>` con los mismos elementos, pero ahora con capacidades de depuración añadidas.

Ahora, el método genérico que creamos anteriormente podríamos haberlo creado de la siguiente manera, utilizando la
interfaz funcional `UnaryOperator<T>`, dado que esta interfaz extiende a la interfaz funcional `Function<T,T>`.

````java
private static <T> UnaryOperator<Flux<T>> addDebugger() {
    return flux -> flux
            .doOnNext(value -> log.info("recibido: {}", value))
            .doOnError(throwable -> log.error("error", throwable))
            .doOnComplete(() -> log.info("Completado"));
}
````

`UnaryOperator<Flux<T>>`: Este es un caso especial de `Function<T, T>` cuando el tipo de entrada y el tipo de salida
son el mismo (`Flux<T>` en este caso). Al usar `UnaryOperator`, simplemente indicas que el método devuelve una función
que toma y devuelve un `Flux<T>` del mismo tipo, lo que en realidad es una simplificación semántica del uso de
`Function<Flux<T>, Flux<T>>`.

````java

public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    record Customer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }

    public static void main(String[] args) {
        getCustomers()
                .transform(addDebugger())
                .subscribe();

        getPurchaseOrders()
                .transform(addDebugger())
                .subscribe();
    }

    private static Flux<Customer> getCustomers() {
        return Flux.range(1, 3)
                .map(number -> new Customer(number, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(number -> new PurchaseOrder(Util.faker().commerce().productName(), number, number * 10));
    }

    /**
     * Obtenemos un flujo, añadimos los operadores y devolvemos el flujo
     */
    private static <T> UnaryOperator<Flux<T>> addDebugger() {
        return flux -> flux
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error("error", throwable))
                .doOnComplete(() -> log.info("Completado"));
    }
}
//d.m.a.s.Lec10Transform         : recibido: Customer[id=1, name=Cary]
//d.m.a.s.Lec10Transform         : recibido: Customer[id=2, name=Garrett]
//d.m.a.s.Lec10Transform         : recibido: Customer[id=3, name=Adrian]
//d.m.a.s.Lec10Transform         : Completado
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Durable Silk Bag, price=1, quantity=10]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Awesome Wooden Hat, price=2, quantity=20]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Incredible Iron Computer, price=3, quantity=30]
//d.m.a.s.Lec10Transform         : Completado
````

Ahora, supongamos que por alguna razón queremos controlar cuándo ejecutar la función del transform y cuándo no. Para
eso podemos aplicar el siguiente código dentro del operador
`transform(isDebugEnabled ? addDebugger() : Function.identity())`.

````java

public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    record Customer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }

    public static void main(String[] args) {
        boolean isDebugEnabled = false;
        getCustomers()
                .transform(isDebugEnabled ? addDebugger() : Function.identity())
                .subscribe();

        getPurchaseOrders()
                .transform(addDebugger())
                .subscribe();
    }

    private static Flux<Customer> getCustomers() {
        return Flux.range(1, 3)
                .map(number -> new Customer(number, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(number -> new PurchaseOrder(Util.faker().commerce().productName(), number, number * 10));
    }

    /**
     * Obtenemos un flujo, añadimos los operadores y devolvemos el flujo
     */
    private static <T> UnaryOperator<Flux<T>> addDebugger() {
        return flux -> flux
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error("error", throwable))
                .doOnComplete(() -> log.info("Completado"));
    }
}
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Enormous Paper Clock, price=1, quantity=10]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Fantastic Concrete Lamp, price=2, quantity=20]
//d.m.a.s.Lec10Transform         : recibido: PurchaseOrder[productName=Enormous Cotton Watch, price=3, quantity=30]
//d.m.a.s.Lec10Transform         : Completado
````

`Function.identity()`, devuelve una función que siempre devuelve su argumento de entrada.

En el código anterior al estar la variable `isDebugEnabled` en `false` no agregamos la función `addDebugger()`, sino,
por el contrario, usamos la función `Function.identity()`, para que devuelva lo mismo que recibe. En ese sentido,
como resultado vemos que solo imprime los mensajes del `getPurchaseOrders()` y no del `getCustomers()`.

## Trabajo asignado (Assignment)

- Tenemos 4 ids de productos: 1, 2, 3, 4.
- Obtener el nombre del producto usando `product-service`.
- Timeout 2 segundos.
    - Llama al servicio `fallback for timeout` para obtener el nombre del producto.
- Llama al servicio `fallback for empty` para obtener el nombre del producto en caso de que esté vacío.
- Deje que la clase cliente abstraiga el manejo de tiempos de espera y tiempos vacíos.
    - client.getProductName(1)

En el tutorial usa 3 servicios rest para buscar un producto usando solicitudes http. En mi caso, crearé tres conjuntos
de productos, las cuales simularán los servicios. Uno será el servicio por defecto, otro el servicio que se llamará
cuando se exceda el timeout de 2 segundos y un último servicio que se llamará cuando el servicio por defecto retorne
vacío.

````java

public class ProductService {

    private static final Logger log = LoggerFactory.getLogger(ProductService.class);
    private static final boolean IS_EMPTY = false;

    public Mono<String> getProductName(Long productId) {
        return this.getProductsDefault()
                .switchIfEmpty(getProductsTimeoutEmpty())
                .timeout(Duration.ofSeconds(2), getProductsTimeoutFallback())
                .doOnNext(product -> log.info("product: {}", product))
                .filter(product -> product.id().equals(productId))
                .next()
                .map(Product::name);
    }

    private Flux<Product> getProductsDefault() {
        return IS_EMPTY ?
                Flux.empty() :
                Flux.just(
                                new Product(1L, "Monitor", 15.50),
                                new Product(2L, "Teclado", 19.90),
                                new Product(3L, "Mouse", 65.50),
                                new Product(4L, "UPS", 295.80)
                        )
                        .delayElements(Duration.ofSeconds(4)); //Los elementos serán emitidos cada 4s
    }

    public Flux<Product> getProductsTimeoutFallback() {
        return Flux.just(
                new Product(1L, "Monitor (timeoutFallback)", 15.50),
                new Product(2L, "Teclado (timeoutFallback)", 19.90),
                new Product(3L, "Mouse (timeoutFallback)", 65.50),
                new Product(4L, "UPS (timeoutFallback)", 295.80)
        );
    }

    public Flux<Product> getProductsTimeoutEmpty() {
        return Flux.just(
                new Product(1L, "Monitor (timeoutEmpty)", 15.50),
                new Product(2L, "Teclado (timeoutEmpty)", 19.90),
                new Product(3L, "Mouse (timeoutEmpty)", 65.50),
                new Product(4L, "UPS (timeoutEmpty)", 295.80)
        );
    }
}
//d.m.a.s.a.ProductService       : product: Product[id=1, name=Monitor (timeoutFallback), price=15.5]
//d.m.a.common.DefaultSubscriber :  recibido: Monitor (timeoutFallback)
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

- `next()`, emite solo el primer elemento emitido por este `Flux` en un nuevo `Mono`. Si se llama en un `Flux` vacío,
  emite un `Mono` vacío.
- `next()`, evita el procesamiento innecesario de los demás elementos del `Flux` una vez que se encuentra el elemento
  deseado.

````java
public class Lec11Assignment {
    public static void main(String[] args) {
        ProductService productService = new ProductService();
        Mono<String> productName = productService.getProductName(1L);
        productName.subscribe(Util.subscriber());

        Util.sleepSeconds(15);
    }
}
````
