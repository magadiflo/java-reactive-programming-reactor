# Sección 05: Operators

---

## Operador - Handle

Es un operador avanzado que permite combinar la funcionalidad de los operadores `map()` y `filter()`. Te permite
transformar, filtrar o descartar elementos dentro de un `Publisher` (como un `Flux` o un `Mono`), lo que lo hace muy
versátil.

La firma del método es:

````java
public final <V> Flux<V> handle(BiConsumer<? super T, SynchronousSink<V>> handler)
````

- `T` es el tipo de los elementos que se están procesando en el `Flux`.
- `V` es el tipo de los elementos que producirá después de la operación de `handle()`.
- `SynchronousSink<V>` es un callback que te permite emitir elementos de forma síncrona, permitiéndote transformar o
  filtrar el flujo de datos.

**¿Qué puedes hacer con handle()?**

1. Transformar elementos: Puedes modificar o transformar los elementos en el flujo.
2. Filtrar elementos: Al no emitir un valor en el SynchronousSink, puedes descartar elementos del flujo.
3. Emitir múltiples elementos: Puedes emitir más de un elemento o no emitir ninguno.

````java

/**
 * Con el operador .handle() cumplamos los siguientes criterios
 * 1 => -2
 * 4 => no enviarlo
 * 7 => error
 * En los otros casos => enviarlos
 */
public class Lec01Handle {
    public static void main(String[] args) {
        Flux.range(1, 10)
                .filter(i -> i != 7)
                .handle((item, synchronousSink) -> {
                    switch (item) {
                        case 1 -> synchronousSink.next(-2);
                        case 4 -> {
                        }
                        case 7 -> synchronousSink.error(new RuntimeException("Valor 7, lanzando error"));
                        default -> synchronousSink.next(item);
                    }
                })
                .subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: -2
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 5
//d.m.a.common.DefaultSubscriber :  recibido: 6
//d.m.a.common.DefaultSubscriber :  recibido: 8
//d.m.a.common.DefaultSubscriber :  recibido: 9
//d.m.a.common.DefaultSubscriber :  recibido: 10
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

Este ejemplo destaca cómo puedes usar `.handle()` para realizar múltiples operaciones de transformación y filtrado
dentro de una única operación. La lógica que se muestra permite manipular de manera condicional ciertos valores y
aplicar transformaciones, como emitir `-2` en lugar de `1`, filtrar el `4` y manejar potenciales `errores` (aunque en
este caso no se alcanzaría el error por el filter inicial).

## Operator - Handle Assignment

````java
public class Lec02HandleUntilAssignment {
    public static void main(String[] args) {
        // Este flujo (generate) está generando nombres de países de manera infinita.
        Flux<String> generate = Flux.generate(synchronousSink -> {
            synchronousSink.next(Util.faker().country().name());
        });

        // En resumen, este bloque de código está manipulando el flujo para que continúe 
        // emitiendo nombres de países hasta que aparezca "Peru". Una vez que eso sucede, el flujo se termina.
        Flux<String> handle = generate.handle((countryName, synchronousSink) -> {
            synchronousSink.next(countryName);
            if (countryName.equalsIgnoreCase("Peru")) {
                synchronousSink.complete();
            }
        });

        handle.subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: Malta
//d.m.a.common.DefaultSubscriber :  recibido: Korea, Republic of
//d.m.a.common.DefaultSubscriber :  recibido: Ukraine
//d.m.a.common.DefaultSubscriber :  recibido: Iceland
//d.m.a.common.DefaultSubscriber :  recibido: China
//d.m.a.common.DefaultSubscriber :  recibido: Costa Rica
//...
//d.m.a.common.DefaultSubscriber :  recibido: Iran (Islamic Republic of)
//d.m.a.common.DefaultSubscriber :  recibido: Turkmenistan
//d.m.a.common.DefaultSubscriber :  recibido: Cyprus
//d.m.a.common.DefaultSubscriber :  recibido: Estonia
//d.m.a.common.DefaultSubscriber :  recibido: Peru
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

- `Flux.generate()` es una forma de generar elementos de forma síncrona, uno por uno. Aquí, se está creando un Flux que
  genera nombres de países de manera indefinida utilizando Util.faker().country().name(). Esto simula una fuente
  continua de datos que emite un nuevo nombre de país cada vez que se solicita.

- `synchronousSink.next(...)`: Este es el mecanismo que se usa para emitir el nombre del país generado en cada
  iteración.

- El operador `.handle()` toma el flujo generado (generate) y lo manipula.

- `countryName`: Representa el nombre del país que ha sido emitido por el flujo.

-`synchronousSink.next(countryName)`: Vuelve a emitir el nombre del país sin cambios. Esto permite que el flujo continúe
emitiendo los nombres generados.

- Condicional con if `(countryName.equalsIgnoreCase("Peru"))`: Si el nombre del país es `Peru`, el flujo se completa
  llamando a `synchronousSink.complete()`. Esto significa que tan pronto como aparezca `Peru` en el flujo, el `Flux`
  detendrá su emisión y completará la secuencia.

## Do Hooks/Callbacks

Los operadores de la familia do... (como `doOnNext`, `doFirst`, `doComplete`, etc.) se utilizan para agregar acciones
secundarias o efectos secundarios en un flujo reactivo. A diferencia de operadores como `map()` o `filter()`, no
modifican el flujo de datos, sino que te permiten ejecutar lógica adicional en momentos específicos del ciclo de vida
de un `Publisher` (como `Flux` o `Mono`).

````java
  public static void main(String[] args) {
    Flux.<Integer>create(fluxSink -> {
                log.info("Inicia el productor");
                for (int i = 0; i < 4; i++) {
                    fluxSink.next(i);
                }
                fluxSink.complete();
//                     fluxSink.error(new RuntimeException("oops"));
                log.info("Finaliza el productor");
            })
            .doOnComplete(() -> log.info("doOnComplete"))
            .doFirst(() -> log.info("doFirst"))
            .doOnNext(item -> log.info("doOnNext: {}", item))
            .doOnSubscribe(subscription -> log.info("doOnSubscribe: {}", subscription))
            .doOnRequest(request -> log.info("doOnRequest: {}", request))
            .doOnError(error -> log.info("doOnError: {}", error.getMessage()))
            .doOnTerminate(() -> log.info("doOnTerminate")) // complete or error case
            .doOnCancel(() -> log.info("doOnCancel"))
            .doOnDiscard(Object.class, o -> log.info("doOnDiscard: {}", o))
            .doFinally(signal -> log.info("doFinally: {}", signal)) // finally irrespective of the reason
            .subscribe(Util.subscriber("subscriber"));
}
//d.m.a.o.Lec03DoCallbacks       : doFirst
//d.m.a.o.Lec03DoCallbacks       : doOnSubscribe: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@5fbe4146
//d.m.a.o.Lec03DoCallbacks       : doOnRequest: 9223372036854775807
//d.m.a.o.Lec03DoCallbacks       : Inicia el productor
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 0
//d.m.a.common.DefaultSubscriber : subscriber recibido: 0
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 1
//d.m.a.common.DefaultSubscriber : subscriber recibido: 1
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 2
//d.m.a.common.DefaultSubscriber : subscriber recibido: 2
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 3
//d.m.a.common.DefaultSubscriber : subscriber recibido: 3
//d.m.a.o.Lec03DoCallbacks       : doOnComplete
//d.m.a.o.Lec03DoCallbacks       : doOnTerminate
//d.m.a.common.DefaultSubscriber : subscriber ¡completado!
//d.m.a.o.Lec03DoCallbacks       : doFinally: onComplete
//d.m.a.o.Lec03DoCallbacks       : Finaliza el productor
````

## Operador - doOnNext - Aclaración

El operador doOnNext en Project Reactor se utiliza para ejecutar una acción secundaria cada vez que el flujo (Mono o
Flux) emite un elemento. Este operador es parte de la familia de operadores do..., que permiten agregar efectos
secundarios (side effects) sin modificar los datos del flujo.

- La inmutabilidad es buena, pero no significa que la mutación sea mala.
- La `programación funcional` prefiere las` funciones puras` (sin efectos secundarios).
    - Deberíamos preferir las funciones puras.

Veamos el siguiente ejemplo.

````java
public class CustomerServiceImpl implements CustomerService {

    @Override
    public Mono<Customer> updateCustomer() {
        return this.repository.findById(123)
                .doOnNext(customer -> customer.setAge(10))
                .flatMap(this.repository::save);
    }

}
````

Estamos trabajando con una entidad `Customer`. Nuestras entidades son objetos `mutables`. En el código anterior estamos
obteniendo un usuario de la base de datos a través de su identificador, esto nos retorna un `Mono<Customer>`, por lo
que no sabemos cuándo obtendremos el objeto `Customer`. En ese sentido, como queremos actualizar el valor de la edad
del objeto buscado, necesitamos utilizar el operador `doOnNext` para realizar esa operación. El `Project Reactor`
proporciona ciertas garantías de que se sincronizará internamente cuando realizamos la mutación `customer.setAge(10)`,
esto lo hace un hilo y ningún otro hilo vendrá y lo cambiará. 