# Sección 05: Operators

---

## Operador - Handle

Es un operador avanzado que permite combinar la funcionalidad de los operadores `map()` y `filter()`. Te permite
transformar, filtrar o descartar elementos dentro de un `Publisher` (como un `Flux` o un `Mono`), lo que lo hace muy
versátil.

La firma del método es:

````java
public final <V> Flux<V> handle(BiConsumer<? super T, SynchronousSink<V>> handler)
````

- `T` es el tipo de los elementos que se están procesando en el `Flux`.
- `V` es el tipo de los elementos que producirá después de la operación de `handle()`.
- `SynchronousSink<V>` es un callback que te permite emitir elementos de forma síncrona, permitiéndote transformar o
  filtrar el flujo de datos.

**¿Qué puedes hacer con handle()?**

1. Transformar elementos: Puedes modificar o transformar los elementos en el flujo.
2. Filtrar elementos: Al no emitir un valor en el SynchronousSink, puedes descartar elementos del flujo.
3. Emitir múltiples elementos: Puedes emitir más de un elemento o no emitir ninguno.

````java

/**
 * Con el operador .handle() cumplamos los siguientes criterios
 * 1 => -2
 * 4 => no enviarlo
 * 7 => error
 * En los otros casos => enviarlos
 */
public class Lec01Handle {
    public static void main(String[] args) {
        Flux.range(1, 10)
                .filter(i -> i != 7)
                .handle((item, synchronousSink) -> {
                    switch (item) {
                        case 1 -> synchronousSink.next(-2);
                        case 4 -> {
                        }
                        case 7 -> synchronousSink.error(new RuntimeException("Valor 7, lanzando error"));
                        default -> synchronousSink.next(item);
                    }
                })
                .subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: -2
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 5
//d.m.a.common.DefaultSubscriber :  recibido: 6
//d.m.a.common.DefaultSubscriber :  recibido: 8
//d.m.a.common.DefaultSubscriber :  recibido: 9
//d.m.a.common.DefaultSubscriber :  recibido: 10
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

Este ejemplo destaca cómo puedes usar `.handle()` para realizar múltiples operaciones de transformación y filtrado
dentro de una única operación. La lógica que se muestra permite manipular de manera condicional ciertos valores y
aplicar transformaciones, como emitir `-2` en lugar de `1`, filtrar el `4` y manejar potenciales `errores` (aunque en
este caso no se alcanzaría el error por el filter inicial).

## Operator - Handle Assignment

````java
public class Lec02HandleUntilAssignment {
    public static void main(String[] args) {
        // Este flujo (generate) está generando nombres de países de manera infinita.
        Flux<String> generate = Flux.generate(synchronousSink -> {
            synchronousSink.next(Util.faker().country().name());
        });

        // En resumen, este bloque de código está manipulando el flujo para que continúe 
        // emitiendo nombres de países hasta que aparezca "Peru". Una vez que eso sucede, el flujo se termina.
        Flux<String> handle = generate.handle((countryName, synchronousSink) -> {
            synchronousSink.next(countryName);
            if (countryName.equalsIgnoreCase("Peru")) {
                synchronousSink.complete();
            }
        });

        handle.subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: Malta
//d.m.a.common.DefaultSubscriber :  recibido: Korea, Republic of
//d.m.a.common.DefaultSubscriber :  recibido: Ukraine
//d.m.a.common.DefaultSubscriber :  recibido: Iceland
//d.m.a.common.DefaultSubscriber :  recibido: China
//d.m.a.common.DefaultSubscriber :  recibido: Costa Rica
//...
//d.m.a.common.DefaultSubscriber :  recibido: Iran (Islamic Republic of)
//d.m.a.common.DefaultSubscriber :  recibido: Turkmenistan
//d.m.a.common.DefaultSubscriber :  recibido: Cyprus
//d.m.a.common.DefaultSubscriber :  recibido: Estonia
//d.m.a.common.DefaultSubscriber :  recibido: Peru
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

- `Flux.generate()` es una forma de generar elementos de forma síncrona, uno por uno. Aquí, se está creando un Flux que
  genera nombres de países de manera indefinida utilizando Util.faker().country().name(). Esto simula una fuente
  continua de datos que emite un nuevo nombre de país cada vez que se solicita.

- `synchronousSink.next(...)`: Este es el mecanismo que se usa para emitir el nombre del país generado en cada
  iteración.

- El operador `.handle()` toma el flujo generado (generate) y lo manipula.

- `countryName`: Representa el nombre del país que ha sido emitido por el flujo.

-`synchronousSink.next(countryName)`: Vuelve a emitir el nombre del país sin cambios. Esto permite que el flujo continúe
emitiendo los nombres generados.

- Condicional con if `(countryName.equalsIgnoreCase("Peru"))`: Si el nombre del país es `Peru`, el flujo se completa
  llamando a `synchronousSink.complete()`. Esto significa que tan pronto como aparezca `Peru` en el flujo, el `Flux`
  detendrá su emisión y completará la secuencia.

## Do Hooks/Callbacks

Los operadores de la familia do... (como `doOnNext`, `doFirst`, `doComplete`, etc.) se utilizan para agregar acciones
secundarias o efectos secundarios en un flujo reactivo. A diferencia de operadores como `map()` o `filter()`, no
modifican el flujo de datos, sino que te permiten ejecutar lógica adicional en momentos específicos del ciclo de vida
de un `Publisher` (como `Flux` o `Mono`).

````java
  public static void main(String[] args) {
    Flux.<Integer>create(fluxSink -> {
                log.info("Inicia el productor");
                for (int i = 0; i < 4; i++) {
                    fluxSink.next(i);
                }
                fluxSink.complete();
//                     fluxSink.error(new RuntimeException("oops"));
                log.info("Finaliza el productor");
            })
            .doOnComplete(() -> log.info("doOnComplete"))
            .doFirst(() -> log.info("doFirst"))
            .doOnNext(item -> log.info("doOnNext: {}", item))
            .doOnSubscribe(subscription -> log.info("doOnSubscribe: {}", subscription))
            .doOnRequest(request -> log.info("doOnRequest: {}", request))
            .doOnError(error -> log.info("doOnError: {}", error.getMessage()))
            .doOnTerminate(() -> log.info("doOnTerminate")) // complete or error case
            .doOnCancel(() -> log.info("doOnCancel"))
            .doOnDiscard(Object.class, o -> log.info("doOnDiscard: {}", o))
            .doFinally(signal -> log.info("doFinally: {}", signal)) // finally irrespective of the reason
            .subscribe(Util.subscriber("subscriber"));
}
//d.m.a.o.Lec03DoCallbacks       : doFirst
//d.m.a.o.Lec03DoCallbacks       : doOnSubscribe: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@5fbe4146
//d.m.a.o.Lec03DoCallbacks       : doOnRequest: 9223372036854775807
//d.m.a.o.Lec03DoCallbacks       : Inicia el productor
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 0
//d.m.a.common.DefaultSubscriber : subscriber recibido: 0
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 1
//d.m.a.common.DefaultSubscriber : subscriber recibido: 1
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 2
//d.m.a.common.DefaultSubscriber : subscriber recibido: 2
//d.m.a.o.Lec03DoCallbacks       : doOnNext: 3
//d.m.a.common.DefaultSubscriber : subscriber recibido: 3
//d.m.a.o.Lec03DoCallbacks       : doOnComplete
//d.m.a.o.Lec03DoCallbacks       : doOnTerminate
//d.m.a.common.DefaultSubscriber : subscriber ¡completado!
//d.m.a.o.Lec03DoCallbacks       : doFinally: onComplete
//d.m.a.o.Lec03DoCallbacks       : Finaliza el productor
````

## Operador - doOnNext - Aclaración

El operador doOnNext en Project Reactor se utiliza para ejecutar una acción secundaria cada vez que el flujo (Mono o
Flux) emite un elemento. Este operador es parte de la familia de operadores do..., que permiten agregar efectos
secundarios (side effects) sin modificar los datos del flujo.

- La inmutabilidad es buena, pero no significa que la mutación sea mala.
- La `programación funcional` prefiere las` funciones puras` (sin efectos secundarios).
    - Deberíamos preferir las funciones puras.

Veamos el siguiente ejemplo.

````java
public class CustomerServiceImpl implements CustomerService {

    @Override
    public Mono<Customer> updateCustomer() {
        return this.repository.findById(123)
                .doOnNext(customer -> customer.setAge(10))
                .flatMap(this.repository::save);
    }

}
````

Estamos trabajando con una entidad `Customer`. Nuestras entidades son objetos `mutables`. En el código anterior estamos
obteniendo un usuario de la base de datos a través de su identificador, esto nos retorna un `Mono<Customer>`, por lo
que no sabemos cuándo obtendremos el objeto `Customer`. En ese sentido, como queremos actualizar el valor de la edad
del objeto buscado, necesitamos utilizar el operador `doOnNext` para realizar esa operación. El `Project Reactor`
proporciona ciertas garantías de que se sincronizará internamente cuando realizamos la mutación `customer.setAge(10)`,
esto lo hace un hilo y ningún otro hilo vendrá y lo cambiará.

## Operador - Delay Elements

Retrasar cada uno de los elementos de `Flux` (señales Subscriber. `onNext`) durante una duración determinada. Las
señales se retrasan y continúan en el Scheduler predeterminado paralelo, pero las secuencias vacías o las señales de
error inmediato no se retrasan.

El operador `delayElements()` en Project Reactor introduce un retraso entre la emisión de cada elemento en un `Flux`.
Su propósito es emitir los elementos con una demora específica sin bloquear el hilo en el que se está ejecutando, lo
que lo hace ideal para escenarios reactivos.

````java
public class Lec04Delay {
    public static void main(String[] args) {
        /**
         * El Delay Element se aplicará en un hilo separado
         */
        Flux.range(1, 5)
                .delayElements(Duration.ofSeconds(1))
                .subscribe(Util.subscriber());

        /**
         * Bloqueamos el hilo principal para ver los valores que se están emitiendo
         */
        Util.sleepSeconds(11);
    }
}
````

En el ejemplo anterior, se emitirá un número cada segundo. Internamente, `delayElements()` trabaja utilizando un
`Scheduler`, permitiendo que los elementos se emitan sin bloquear el hilo principal.

Ahora, solo para este ejemplo, como nos interesa ver cómo se van emitiendo los valores, necesitamos bloquear el hilo
principal utilizando `Thread.sleep` para evitar que el programa termine antes de que se emitan todos los elementos.

## doOnNext, doOnError y doOnComplete

En este curso hemos estado usando el método estático `Util.subscriber()` para mostrar la información que emite los flux.
Recordemos que este método nos retorna una implementación propia que creamos del `Subscriber`, donde implementamos los
métodos `onNext`, `onError` y `onComplete`.

En algunos casos, convendría hacer uso de de los operadores `.doOnNext()`, `.doOnError()` o `.doOnComplete()`, tal como
se ve en el siguiente ejemplo:

````java
public class Lec05Subscribe {

    private static final Logger log = LoggerFactory.getLogger(Lec05Subscribe.class);

    public static void main(String[] args) {
        Flux.range(1, 10)
                .doOnNext(number -> log.info("recibido: {}", number))
                .doOnError(err -> log.error("error", err))
                .doOnComplete(() -> log.info("Completado"))
                .subscribe();
    }
}
````

## Error Handling - onErrorReturn

Supongamos que tenemos el siguiente ejemplo, donde se emiten números y cuando el número emitido sea 5 lo dividimos entre
cero, eso nos dará un error, así que veamos el comportamiento.

````java
public static void main(String[] args) {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  error: / by zero
````

Para solucionar ese error, podemos utilizar el operador `.onErrorReturn()` para devolver un valor predeterminado
en caso ocurra un error similar al ejemplo anterior.

El operador `onErrorReturn()` emite un valor de respaldo capturado cuando se observe algún error en el flux.
El operador `onErrorReturn()` de `Project Reactor` finaliza el flujo después de devolver el valor especificado cuando
ocurre un error. Es decir, una vez que se captura una excepción y se emite el valor de retorno, el flujo se completa,
aunque queden más elementos por emitir.

````java
public static void main(String[] args) {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .onErrorReturn(-1)
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: -1
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

**Importante**

> Es importante la ubicación del operador `.onErrorReturn()`, por lo general podríamos colocarlo casi al final para
> que esté pendiente de todo el flujo.

Ahora, supongamos que queremos retornar un valor en caso de una excepción, pero siempre y cuando sea en función de una
excepción específica. Por ejemplo, si ocurre la excepción `IllegalArgumentException`, solo en ese caso se emitirá como
valor de retorno el `-1`.

````java
private static void onErrorReturn2() {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .onErrorReturn(IllegalArgumentException.class, -1)
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  error: / by zero
````

En el ejemplo anterior, estamos recibiendo el error y finalizando el flux, dado que en el operador `onErrorResume()`
esperábamos un error del tipo `IllegalArgumentException` para retornar un `-1`, pero el error que obtuvimos fue
del tipo `ArithmeticException`, es por eso que se continuó propagando el error hasta el `subscribe`.

Podemos agrega tantos operadores `onErrorReturn` como quisiéramos especificando la excepción que se debe lanzar para
poder retornar un determinado valor.

````java
private static void onErrorReturn2() {
    Flux.range(1, 10)
            .map(number -> number == 5 ? 5 / 0 : number) //intencional
            .onErrorReturn(IllegalArgumentException.class, -1)
            .onErrorReturn(ArithmeticException.class, -2)
            .onErrorReturn(-3) // En caso de cualquier otra excepción se retornará -3
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: -2
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Error Handling - onErrorResume

En la sección anterior donde usámos el operador `onErrorReturn()` vimos que podemos retornar un valor previamente
definido, un valor en código duro, pero qué pasa si queremos calcular el valor, en este escenario `Reactor` nos
proporciona otro operador `onErrorResume()`.

El operador `onErrorResume()` en `Project Reactor` es una forma de manejar errores de manera más flexible que
`onErrorReturn()`. Mientras que `onErrorReturn()` devuelve un valor específico cuando ocurre un error y luego
completa el flujo, `onErrorResume()` permite continuar el flujo a partir de una nueva fuente `(Publisher)` cuando
ocurre una excepción.

Entonces, cuando el flujo original encuentra un error, `onErrorResume()` te permite manejar ese error y continuar
emitiendo elementos desde otro `Flux o Mono`. En lugar de simplemente devolver un valor de `fallback`, puedes decidir
qué hacer en función del tipo o contenido del error.

````java

public class Lec06ErrorHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        Flux.range(1, 10)
                .map(number -> number == 5 ? 5 / 0 : number) //intencional
                .onErrorResume(throwable -> fallback())
                .subscribe(Util.subscriber());
    }

    // Imaginemos que es un servicio alternativo
    private static Mono<Integer> fallback() {
        return Mono.fromSupplier(() -> Util.faker().random().nextInt(10, 100));
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: 48
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

En el siguiente ejemplo, observamos que luego que ocurre el error, el operador `onErrorResume()` entra en acción, se
llama al método `fallback2()` y se empieza a emitir un nuevo flux.

````java

public class Lec06ErrorHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorResume2();
    }

    private static Flux<Integer> fallback2() {
        return Flux.range(50, 5);
    }

    private static void onErrorResume2() {
        Flux.range(1, 10)
                .map(number -> number == 5 ? 5 / 0 : number) //intencional
                .onErrorResume(throwable -> fallback2())
                .subscribe(Util.subscriber());
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: 1
//d.m.a.common.DefaultSubscriber :  recibido: 2
//d.m.a.common.DefaultSubscriber :  recibido: 3
//d.m.a.common.DefaultSubscriber :  recibido: 4
//d.m.a.common.DefaultSubscriber :  recibido: 50
//d.m.a.common.DefaultSubscriber :  recibido: 51
//d.m.a.common.DefaultSubscriber :  recibido: 52
//d.m.a.common.DefaultSubscriber :  recibido: 53
//d.m.a.common.DefaultSubscriber :  recibido: 54
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

En el siguiente ejemplo supongamos que el flux emite un error del tipo `RuntimeException`, entonces el primer operador
`onErrorResume()` está esperando un tipo `ArithmeticException` para ejecutar el `fallback1()`, pero como la excepción
es del tipo `RuntimeException`, se pasa al siguiente operador `onErrorResume()` quien ejecuta el `fallback3()`. Ahora,
esperaríamos que el `fallback3()` emita elementos, pero intencionalmente estamos emitiendo un error, suponiendo que
algo falló en dicho método. Entonces, el flujo continuará hacia el operador `onErrorReturn()` donde finalmente se
lanzará el valor `-5`.

````java

public class Lec06ErrorHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorResume3();
    }

    private static void onErrorResume3() {
        Flux.error(new RuntimeException("Oops"))
                .onErrorResume(ArithmeticException.class, e -> fallback1())
                .onErrorResume(throwable -> fallback3())
                .onErrorReturn(-5)
                .subscribe(Util.subscriber());
    }

    private static Mono<Integer> fallback1() {
        return Mono.fromSupplier(() -> Util.faker().random().nextInt(10, 100));
    }

    private static Flux<Integer> fallback3() {
        return Flux.error(new IllegalArgumentException("Ocurrió un error"));
    }
}
//d.m.a.common.DefaultSubscriber :  recibido: -5
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Error Handling - onErrorComplete

Simplemente, complete la secuencia reemplazando una señal `onError` con una señal `onComplete`. Todas las demás señales
se propagan tal como están.

````java
private static void onErrorComplete1() {
    Mono.error(new RuntimeException("Oops"))
            .onErrorComplete()
            .subscribe(Util.subscriber());
}
//d.m.a.common.DefaultSubscriber :  ¡completado!
````

