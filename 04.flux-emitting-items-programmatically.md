# Sección 04: Flux - Emitting Items Programmatically

---

En la sección anterior, habíamos hablado de algunas opciones para crear `Flux`. Todo eso era como crear un flux a partir
de una `List`, `Array`, etc. eso es bueno cuando ya tienes esos tipos en algún lugar de tu código y puedes crear un
flux a partir de ahí.

Nosotros como desarrolladores necesitamos la capacidad de emitir un elemento mediante programación, seguir emitiendo
datos hasta que se cumpla una condición, así que Reactor ofrece un par de opciones para este escenario.

## Flux Create

Cree mediante programación un Flux con la capacidad de emitir múltiples elementos de manera sincrónica o asincrónica a
través de la `API FluxSink`. Esto incluye la emisión de elementos desde múltiples subprocesos.

Permite crear manualmente un flujo (Flux) al emitir eventos de manera programática a través de un callback (función de
retorno). Es uno de los métodos más flexibles para generar flujos porque otorga al desarrollador control total sobre
cómo y cuándo se emiten los elementos, lo que es útil en escenarios donde los datos no están disponibles de forma
inmediata o dependen de eventos externos.

````java
public class Lec01FluxCreate {
    public static void main(String[] args) {
        /**
         * A veces podemos tener un requisito donde nos pidan seguir haciendo algo
         * hasta que se cumpla cierta condición.
         */
        Flux<String> nameFlux = Flux.create(fluxSink -> {
            String country;
            do {
                country = Util.faker().country().name();
                fluxSink.next(country);
            } while (!country.equalsIgnoreCase("Peru"));
            fluxSink.complete();
        });
        nameFlux.subscribe(Util.subscriber());
    }
}
````

## Flux Create - Refactor

Si revisamos el código anterior, vemos que implementamos la lógica dentro del propio `create()`, es decir, hemos
implementado el `consumer`.

Podría darse el caso en el que la lógica que implementemos sea muy grande, por lo que sería poco legible el poder
tenerlo dentro del operador `create()`, en ese sentido, podríamos crear una clase que implemente lo que el operador
`create()` espera como parámetro: `Consumer<? super FluxSink<T>> emitter`.

La clase que creemos nos permitirá manejar de manera más centralizada la lógica que quisieramos implementar, así que
esta sería una forma de poder refactorizar el código que creamos en el apartado anterior.

````java
public class NameGenerator implements Consumer<FluxSink<String>> {

    private FluxSink<String> fluxSink;

    @Override
    public void accept(FluxSink<String> stringFluxSink) {
        this.fluxSink = stringFluxSink;
    }

    public void generate() {
        this.fluxSink.next(Util.faker().name().firstName());
    }
}
````

Una vez definida la clase con la lógica implementada, la podemos definir ahora en el operador `create()` de la
siguiente manera. Luego, usando un bucle for, podemos ir emitiendo los valores.

````java
public class Lec02FluxCreateRefactor {
    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(Util.subscriber());

        for (int i = 0; i < 10; i++) {
            nameGenerator.generate();
        }
    }
}
````

## Flux Sink - Thread Safety (seguridad del hilo)

Primero demostraremos algo que no es seguro para los hilos, posteriormente haremos un ejemplo donde mostraremos la
seguridad en los hilos al usar un `FluxSink`.

### Demostrando que el ArrayList no es seguro para hilos (No Thread Safety)

En siguiente ejemplo usamos un `ArrayList` y creamos `10 hilos`. Cada hilo ejecuta un bucle de `1000` iteraciones
para insertar en la lista, por lo que al final, esperaríamos que la lista contenga `10_000` elementos.

````java
public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        noThreadSafety();
    }

    private static void noThreadSafety() {
        List<Integer> list = new ArrayList<>();
        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        };
        // Lanzamos 10 hilos
        for (int i = 0; i < 10; i++) {
            //new Thread(runnable).start(); //Crea un hilo e inicia la ejecución en java 17
            Thread.ofPlatform().start(runnable); //Crea un hilo e inicia la ejecución en java +19
        }
        Util.sleepSeconds(3);
        log.info("list size: {}", list.size());
    }
}

// En cada ejecución muestra un resultado distinto, lo que en realidad deberíamos esperar es que
// el tamaño de la lista a retornar sea de 10_000, dado que hemos creado 10 hilos y cada hilo agrega a la
// lista un total de 1000 registros.
//
//list size: 5528
//list size: 8036
//list size: 6626
````

El comportamiento que estamos viendo se debe a que `ArrayList` no es seguro para hilos. Esto significa que cuando
varios hilos intentan modificar la lista simultáneamente, puede ocurrir una `condición de carrera`, lo que provoca
que los resultados sean inconsistentes, como el tamaño variable de la lista que observas cada vez que ejecutas el
código.

`Condición de carrera`: En el código, múltiples hilos están intentando agregar elementos a la misma instancia de
`ArrayList` al mismo tiempo. Sin embargo, `ArrayList` no está diseñado para manejar modificaciones concurrentes de
manera segura.

La operación `list.add(i)` puede implicar varios pasos internamente, como verificar la capacidad, redimensionar el
arreglo interno y finalmente agregar el elemento. Si varios hilos intentan acceder a la lista simultáneamente sin
mecanismos de sincronización, algunos elementos pueden sobrescribirse o perderse, lo que provoca que el tamaño final
sea menor del esperado.

### Demostrando que FluxSink sí es seguro para hilos (Thread Safety)

Ahora vamos a ver como el `FluxSink` es seguro para el hilo. Aunque aquí usamos el `ArrayList` para almacenar
los valores, es importante observar que el mecanismo construido es distinto al código anterior. Aquí estamos usando
el `FluxSink` cuya sincronización se comparte con los `múltiples hilos`. Este `FluxSink` una vez que obtiene el
elemento correcto no lo perderá y lo transferirá al `Subscriber` secuencialmente.

````java

public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        threadSafety();
    }

    public static void threadSafety() {
        List<String> list = new ArrayList<>();
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(list::add);

        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                nameGenerator.generate();
            }
        };
        // Lanzamos 10 hilos
        for (int i = 0; i < 10; i++) {
            //new Thread(runnable).start(); //java 17
            Thread.ofPlatform().start(runnable); //java 21
        }
        Util.sleepSeconds(3);
        log.info("FluxSink. list size: {}", list.size());
    }
}
//list size: 10000
````

Ahora, cada vez que ejecutamos la aplicación nuestra lista siempre contendrá los `10_000` elementos, de esta manera
comprobamos que el `FluxSink` es seguro para hilos.

## Flux Create - Comportamiento por defecto

El operador `Flux.create()` en `Project Reactor` es un método que te permite crear un `Flux` de manera programática y
flexible. Este operador acepta una función que recibe como parámetro un objeto `FluxSink`, el cual actúa como una
interfaz para emitir los elementos de la secuencia reactiva.

**FluxSink en detalle:**

`FluxSink` es el componente clave que proporciona control sobre cómo y cuándo los elementos del `Flux` son emitidos.
Permite emitir elementos de manera sincrónica o asincrónica según lo requiera tu caso de uso. Aquí algunos de sus
métodos más importantes:

1. `next(T value)`: Emite el siguiente valor a los suscriptores del `Flux`.
    - Ejemplo: `fluxSink.next("Elemento 1");`
2. `complete()`: Indica el final de la emisión. Después de llamar a este método, no se emiten más elementos y los
   suscriptores reciben la señal de `onComplete`.
    - Ejemplo: `fluxSink.complete();`
3. `error(Throwable t)`: Envía un error a los suscriptores, lo cual termina la secuencia con una señal de `onError`.
   Después de emitir un error, no se pueden emitir más elementos.
    - Ejemplo: `fluxSink.error(new RuntimeException("Ocurrió un error"));`
4. `Backpressure Support (soporte de contrapresión)`:
    - `FluxSink` permite la gestión de la contrapresión mediante la configuración de estrategias de retención de
      elementos con los métodos `onRequest` y `onDispose`.
    - Por ejemplo, puedes monitorear cuántos elementos han sido solicitados por el suscriptor y ajustar la cantidad de
      elementos emitidos en consecuencia para evitar saturación de recursos.
5. Modos de emisión:
    - `BUFFER` (predeterminado): Almacena los elementos emitidos cuando hay un retraso en la solicitud.
    - `DROP`: Descarta los elementos que no pueden ser procesados.
    - `ERROR`: Lanza una excepción cuando el flujo de datos es mayor al que los suscriptores pueden manejar.

A continuación se muestra un ejemplo del `Flux.create()` con el uso del `FluxSink`.

````java
public class Lec04FluxCreateDownStreamDemand {

    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownStreamDemand.class);

    public static void main(String[] args) {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux<String> fluxCreate = Flux.create(fluxSink -> {
            for (int i = 0; i < 10; i++) {
                String name = Util.faker().name().firstName();
                log.info("Generado: {}", name);
                fluxSink.next(name);
            }
            fluxSink.complete();
        });

        fluxCreate.subscribe(subscriber);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);
    }
}
//ec04FluxCreateDownStreamDemand : Generado: Clayton
//ec04FluxCreateDownStreamDemand : Generado: Chuck
//ec04FluxCreateDownStreamDemand : Generado: Gary
//ec04FluxCreateDownStreamDemand : Generado: Hue
//ec04FluxCreateDownStreamDemand : Generado: Elbert
//ec04FluxCreateDownStreamDemand : Generado: Jacquelin
//ec04FluxCreateDownStreamDemand : Generado: Ji
//ec04FluxCreateDownStreamDemand : Generado: Vito
//ec04FluxCreateDownStreamDemand : Generado: Marty
//ec04FluxCreateDownStreamDemand : Generado: Kennith
//d.m.a.p.s.SubscriberImpl       : recibido: Clayton
//d.m.a.p.s.SubscriberImpl       : recibido: Chuck
````

En el ejemplo anterior hacemos uso de un `Suscriber` personalizado `SubscriberImpl` que implementa la interfaz
`Subscriber<T>`. Este suscriptor controlará cómo y cuándo recibir los elementos emitidos por el `Flux`.

Recordemos cómo es que tenemos definido este `Suscriber`:

````java
public class SubscriberImpl implements Subscriber<String> {

    private static final Logger log = LoggerFactory.getLogger(SubscriberImpl.class);
    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
    }

    @Override
    public void onNext(String email) {
        log.info("recibido: {}", email);
    }

    @Override
    public void onError(Throwable throwable) {
        log.error("error", throwable);
    }

    @Override
    public void onComplete() {
        log.info("¡completado!");
    }

    public Subscription getSubscription() {
        return this.subscription;
    }
}
````

Notar que en el método `onSubscribe(...)` estamos asignando la suscripción a una variable global, mismo que será
expuesta a través del método `getSubscription()`. Para que este `SubscriberImpl` empiece a consumir los elementos
emitidos por el `FluxSink` lo que normalmente haría una implementación del `Subscriber` es definir en el método
`onSubscribe()` el siguiente código:

````java

@Override
public void onSubscribe(Subscription subscription) {
    subscription.request(Long.MAX_VALUE); // O el número de elementos a querer consumir, aquí definimos el máximo valor posible
}
````

Pero en nuestro caso no lo tenemos así, dado que la solicitud de los valores a recibir lo haremos a través del método
`subscriber.getSubscription().request(2)`, tal como lo tenemos en nuestro código inicial de ejemplo.

Entonces, el `fluxCreate` se suscribe al `SubscriberImpl`, pero aquí el suscriptor no solicita inmediatamente
los elementos emitidos (ya que en la programación reactiva con soporte de backpressure, el suscriptor tiene el control
de la demanda).

Luego de dormir el programa por 2 segundos con `Util.sleepSeconds(2);`, se llama a
`subscriber.getSubscription().request(2);`, lo que significa que el suscriptor está solicitando recibir solo 2
elementos después de esa pausa.
