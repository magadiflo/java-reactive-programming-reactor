# Sección 04: Flux - Emitting Items Programmatically

---

En la sección anterior, habíamos hablado de algunas opciones para crear `Flux`. Todo eso era como crear un flux a partir
de una `List`, `Array`, etc. eso es bueno cuando ya tienes esos tipos en algún lugar de tu código y puedes crear un
flux a partir de ahí.

Nosotros como desarrolladores necesitamos la capacidad de emitir un elemento mediante programación, seguir emitiendo
datos hasta que se cumpla una condición, así que Reactor ofrece un par de opciones para este escenario.

## Flux Create

Cree mediante programación un Flux con la capacidad de emitir múltiples elementos de manera sincrónica o asincrónica a
través de la `API FluxSink`. Esto incluye la emisión de elementos desde múltiples subprocesos.

Permite crear manualmente un flujo (Flux) al emitir eventos de manera programática a través de un callback (función de
retorno). Es uno de los métodos más flexibles para generar flujos porque otorga al desarrollador control total sobre
cómo y cuándo se emiten los elementos, lo que es útil en escenarios donde los datos no están disponibles de forma
inmediata o dependen de eventos externos.

````java
public class Lec01FluxCreate {
    public static void main(String[] args) {
        /**
         * A veces podemos tener un requisito donde nos pidan seguir haciendo algo
         * hasta que se cumpla cierta condición.
         */
        Flux<String> nameFlux = Flux.create(fluxSink -> {
            String country;
            do {
                country = Util.faker().country().name();
                fluxSink.next(country);
            } while (!country.equalsIgnoreCase("Peru"));
            fluxSink.complete();
        });
        nameFlux.subscribe(Util.subscriber());
    }
}
````

## Flux Create - Refactor

Si revisamos el código anterior, vemos que implementamos la lógica dentro del propio `create()`, es decir, hemos
implementado el `consumer`.

Podría darse el caso en el que la lógica que implementemos sea muy grande, por lo que sería poco legible el poder
tenerlo dentro del operador `create()`, en ese sentido, podríamos crear una clase que implemente lo que el operador
`create()` espera como parámetro: `Consumer<? super FluxSink<T>> emitter`.

La clase que creemos nos permitirá manejar de manera más centralizada la lógica que quisieramos implementar, así que
esta sería una forma de poder refactorizar el código que creamos en el apartado anterior.

````java
public class NameGenerator implements Consumer<FluxSink<String>> {

    private FluxSink<String> fluxSink;

    @Override
    public void accept(FluxSink<String> stringFluxSink) {
        this.fluxSink = stringFluxSink;
    }

    public void generate() {
        this.fluxSink.next(Util.faker().name().firstName());
    }
}
````

Una vez definida la clase con la lógica implementada, la podemos definir ahora en el operador `create()` de la
siguiente manera. Luego, usando un bucle for, podemos ir emitiendo los valores.

````java
public class Lec02FluxCreateRefactor {
    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(Util.subscriber());

        for (int i = 0; i < 10; i++) {
            nameGenerator.generate();
        }
    }
}
````