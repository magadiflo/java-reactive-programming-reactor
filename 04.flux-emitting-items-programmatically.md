# Sección 04: Flux - Emitting Items Programmatically

---

En la sección anterior, habíamos hablado de algunas opciones para crear `Flux`. Todo eso era como crear un flux a partir
de una `List`, `Array`, etc. eso es bueno cuando ya tienes esos tipos en algún lugar de tu código y puedes crear un
flux a partir de ahí.

Nosotros como desarrolladores necesitamos la capacidad de emitir un elemento mediante programación, seguir emitiendo
datos hasta que se cumpla una condición, así que Reactor ofrece un par de opciones para este escenario.

## Flux Create

Cree mediante programación un Flux con la capacidad de emitir múltiples elementos de manera sincrónica o asincrónica a
través de la `API FluxSink`. Esto incluye la emisión de elementos desde múltiples subprocesos.

Permite crear manualmente un flujo (Flux) al emitir eventos de manera programática a través de un callback (función de
retorno). Es uno de los métodos más flexibles para generar flujos porque otorga al desarrollador control total sobre
cómo y cuándo se emiten los elementos, lo que es útil en escenarios donde los datos no están disponibles de forma
inmediata o dependen de eventos externos.

````java
public class Lec01FluxCreate {
    public static void main(String[] args) {
        /**
         * A veces podemos tener un requisito donde nos pidan seguir haciendo algo
         * hasta que se cumpla cierta condición.
         */
        Flux<String> nameFlux = Flux.create(fluxSink -> {
            String country;
            do {
                country = Util.faker().country().name();
                fluxSink.next(country);
            } while (!country.equalsIgnoreCase("Peru"));
            fluxSink.complete();
        });
        nameFlux.subscribe(Util.subscriber());
    }
}
````

## Flux Create - Refactor

Si revisamos el código anterior, vemos que implementamos la lógica dentro del propio `create()`, es decir, hemos
implementado el `consumer`.

Podría darse el caso en el que la lógica que implementemos sea muy grande, por lo que sería poco legible el poder
tenerlo dentro del operador `create()`, en ese sentido, podríamos crear una clase que implemente lo que el operador
`create()` espera como parámetro: `Consumer<? super FluxSink<T>> emitter`.

La clase que creemos nos permitirá manejar de manera más centralizada la lógica que quisieramos implementar, así que
esta sería una forma de poder refactorizar el código que creamos en el apartado anterior.

````java
public class NameGenerator implements Consumer<FluxSink<String>> {

    private FluxSink<String> fluxSink;

    @Override
    public void accept(FluxSink<String> stringFluxSink) {
        this.fluxSink = stringFluxSink;
    }

    public void generate() {
        this.fluxSink.next(Util.faker().name().firstName());
    }
}
````

Una vez definida la clase con la lógica implementada, la podemos definir ahora en el operador `create()` de la
siguiente manera. Luego, usando un bucle for, podemos ir emitiendo los valores.

````java
public class Lec02FluxCreateRefactor {
    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(Util.subscriber());

        for (int i = 0; i < 10; i++) {
            nameGenerator.generate();
        }
    }
}
````

## Flux Sink - Thread Safety (seguridad del hilo)

Primero demostraremos algo que no es seguro para los hilos, posteriormente haremos un ejemplo donde mostraremos la
seguridad en los hilos al usar un `FluxSink`.

### Demostrando que el ArrayList no es seguro para hilos (No Thread Safety)

En siguiente ejemplo usamos un `ArrayList` y creamos `10 hilos`. Cada hilo ejecuta un bucle de `1000` iteraciones
para insertar en la lista, por lo que al final, esperaríamos que la lista contenga `10_000` elementos.

````java
public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        noThreadSafety();
    }

    private static void noThreadSafety() {
        List<Integer> list = new ArrayList<>();
        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        };
        // Lanzamos 10 hilos
        for (int i = 0; i < 10; i++) {
            //new Thread(runnable).start(); //Crea un hilo e inicia la ejecución en java 17
            Thread.ofPlatform().start(runnable); //Crea un hilo e inicia la ejecución en java +19
        }
        Util.sleepSeconds(3);
        log.info("list size: {}", list.size());
    }
}

// En cada ejecución muestra un resultado distinto, lo que en realidad deberíamos esperar es que
// el tamaño de la lista a retornar sea de 10_000, dado que hemos creado 10 hilos y cada hilo agrega a la
// lista un total de 1000 registros.
//
//list size: 5528
//list size: 8036
//list size: 6626
````

El comportamiento que estamos viendo se debe a que `ArrayList` no es seguro para hilos. Esto significa que cuando
varios hilos intentan modificar la lista simultáneamente, puede ocurrir una `condición de carrera`, lo que provoca
que los resultados sean inconsistentes, como el tamaño variable de la lista que observas cada vez que ejecutas el
código.

`Condición de carrera`: En el código, múltiples hilos están intentando agregar elementos a la misma instancia de
`ArrayList` al mismo tiempo. Sin embargo, `ArrayList` no está diseñado para manejar modificaciones concurrentes de
manera segura.

La operación `list.add(i)` puede implicar varios pasos internamente, como verificar la capacidad, redimensionar el
arreglo interno y finalmente agregar el elemento. Si varios hilos intentan acceder a la lista simultáneamente sin
mecanismos de sincronización, algunos elementos pueden sobrescribirse o perderse, lo que provoca que el tamaño final
sea menor del esperado.

### Demostrando que FluxSink sí es seguro para hilos (Thread Safety)

Ahora vamos a ver como el `FluxSink` es seguro para el hilo. Aunque aquí usamos el `ArrayList` para almacenar
los valores, es importante observar que el mecanismo construido es distinto al código anterior. Aquí estamos usando
el `FluxSink` cuya sincronización se comparte con los `múltiples hilos`. Este `FluxSink` una vez que obtiene el
elemento correcto no lo perderá y lo transferirá al `Subscriber` secuencialmente.

````java

public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        threadSafety();
    }

    public static void threadSafety() {
        List<String> list = new ArrayList<>();
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(list::add);

        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                nameGenerator.generate();
            }
        };
        // Lanzamos 10 hilos
        for (int i = 0; i < 10; i++) {
            //new Thread(runnable).start(); //java 17
            Thread.ofPlatform().start(runnable); //java 21
        }
        Util.sleepSeconds(3);
        log.info("FluxSink. list size: {}", list.size());
    }
}
//list size: 10000
````

Ahora, cada vez que ejecutamos la aplicación nuestra lista siempre contendrá los `10_000` elementos, de esta manera
comprobamos que el `FluxSink` es seguro para hilos.

