# Sección 07: [Opcional] - Threading & Schedulers

---

## Introducción

En esta sección hablaremos de los Threading y Schedulers (hilos y planificadores)

## Publisher/Subscriber - Default Thread Demo

En el siguiente ejemplo observamos el comportamiento por defecto cuando dos suscriptores se suscriben al
flujo. Vemos que ambos suscriptores reciben su propio flujo de datos.

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> integerFlux = Flux.create(sink -> {
                    for (int i = 1; i < 3; i++) {
                        log.info("generando: {}", i);
                        sink.next(i);
                    }
                    sink.complete();
                })
                .cast(Integer.class)
                .doOnNext(number -> log.info("value: {}", number));

        integerFlux.subscribe(Util.subscriber("sub1"));
        integerFlux.subscribe(Util.subscriber("sub2"));
    }
}
//[main] m.a.s.Lec01DefaultBehaviorDemo : generando: 1
//[main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
//[main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
//[main] m.a.s.Lec01DefaultBehaviorDemo : generando: 2
//[main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
//[main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
//[main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
//[main] m.a.s.Lec01DefaultBehaviorDemo : generando: 1
//[main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
//[main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
//[main] m.a.s.Lec01DefaultBehaviorDemo : generando: 2
//[main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
//[main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
//[main] d.m.a.common.DefaultSubscriber : sub2 ¡completado!
````

Vemos además que todo el trabajo lo está realizando el hilo principal `[main]`, es decir, el hilo principal es el que
está haciendo la suscripción, debido a eso, termina haciendo todo el trabajo.

En el ejemplo anterior, podemos observar el comportamiento por defecto de `Project Reactor` en cuanto a la ejecución en
un `publisher/subscriber`.

**Comportamiento observado:**

1. `Hilo principal (main thread)`:
   Todas las operaciones (generación de datos y procesamiento de los mismos) se ejecutan en el hilo principal `(main)`,
   ya que no se ha especificado ningún `Scheduler`. Lo que significa que tanto la creación de los elementos en el
   `Flux.create()` como las suscripciones y emisiones se realizan en el hilo principal, secuencialmente.

2. `Suscripciones independientes`:
   El flujo es reproducido completamente desde el inicio para cada suscriptor. Esto significa que cada suscriptor recibe
   su propio conjunto de emisiones, independientemente de los otros suscriptores.
   En el log se ve claramente que la secuencia de generación de valores (generando: 1, generando: 2) ocurre dos veces,
   una por cada suscripción (sub1 y sub2).

Ahora, modifiquemos el ejemplo anterior para suscribirnos dentro de un runnable.

````java

public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> integerFlux = Flux.create(sink -> {
                    for (int i = 1; i < 3; i++) {
                        log.info("generando: {}", i);
                        sink.next(i);
                    }
                    sink.complete();
                })
                .cast(Integer.class)
                .doOnNext(number -> log.info("value: {}", number));

        //dentro del runnable nos estamos suscribiendo
        Runnable runnable = () -> integerFlux.subscribe(Util.subscriber("sub1"));

        // Crea un hilo, le pasa el runnable y lo inicia
        Thread.ofPlatform().start(runnable);
    }
}
//[Thread-0] m.a.s.Lec01DefaultBehaviorDemo : generando: 1
//[Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 1
//[Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
//[Thread-0] m.a.s.Lec01DefaultBehaviorDemo : generando: 2
//[Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 2
//[Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
//[Thread-0] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
````

Ahora vemos que quien se va a suscribir no es el hilo principal, sino que estamos creando un nuevo hilo desde donde
se hará la suscripción. Si nos fijamos en el resultado el hilo `Thread-0` es el que está imprimiendo los resultados y
no el hilo `main` como en el primer ejemplo, es decir, es un nuevo hilo el que está haciendo todo el trabajo.

En este segundo ejemplo, el comportamiento cambia ligeramente porque estás usando un nuevo hilo para realizar la
suscripción al Flux.

**Comportamiento observado:**

1. `Nuevo hilo (Thread-0)`:
   La suscripción al `Flux` ya `no ocurre en el hilo principal (main)`, sino en un `nuevo hilo` que se crea y ejecuta el
   código dentro del Runnable. Esto se evidencia en los logs, donde el hilo que realiza la generación de datos y las
   operaciones relacionadas ahora es `Thread-0`.

2. `Ejecución en el nuevo hilo`:
   Todas las operaciones, desde la generación de los datos en el `Flux.create()` hasta la emisión de esos valores al
   suscriptor, ocurren en el contexto del nuevo hilo `(Thread-0)`, lo cual es diferente del primer ejemplo donde todo
   sucedía en el hilo `main`.

3. `Suscriptor único`:
   A diferencia del primer ejemplo con múltiples suscriptores, aquí solo hay un suscriptor (sub1), y como esperábamos,
   recibe los valores 1 y 2. La generación de los valores y la emisión al suscriptor ocurre de manera secuencial en el
   nuevo hilo.

### Conclusión

En un modelo de `publisher/subscriber` utilizando `Project Reactor` (como con `Flux` y `Mono`), el hilo por defecto en
el que se ejecutan las operaciones depende del contexto en el que se inicia el flujo.

Por defecto, Si no especificas un `Scheduler` explícitamente, el flujo se ejecutará en el mismo hilo en
el que se inició, que generalmente es el hilo principal `("main thread")` o el hilo que invoque la suscripción. Esto
significa que tanto el `publisher` (productor) como el `subscriber` (consumidor) ejecutan sus operaciones en el
mismo hilo.

Ambos ejemplos muestran cómo el contexto de los hilos afecta la ejecución de las operaciones en Project Reactor, y cómo
las suscripciones pueden ejecutarse en diferentes hilos dependiendo de cómo se estructure el código.