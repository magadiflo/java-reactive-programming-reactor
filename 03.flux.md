# Sección 03: Flux

---

### Flux

- Emite `0, 1, 2... N` elementos.
- Seguido por un `onComplete`/`onError`.
- Un `Flux<T>` es un `Publisher<T>` estándar que representa una secuencia asíncrona de `0 a N` elementos emitidos, que
  opcionalmente finaliza mediante una señal de finalización o un error. Como en la especificación de `Reactive Streams`,
  estos tres tipos de señales se traducen en llamadas a los métodos `onNext`, `onComplete` y `onError` de un suscriptor
  descendente.

---

## Flux Just

El método estático `Flux.just()` se utiliza para crear una instancia de `Flux` que emite una secuencia fija y conocida
de elementos. Es una forma sencilla de emitir elementos sin necesidad de manejar operaciones asíncronas complejas. La
secuencia emitida por `Flux.just()` es inmutable, lo que significa que no se puede cambiar después de su creación.

````java
public class Lec01FluxJust {
    public static void main(String[] args) {
        Flux.just(1, 2, 3, 4)
                .subscribe(Util.subscriber());
    }
}
//INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
//INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
//INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
//INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
//INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux - From Array / List

El método `Flux.fromIterable()` en `Project Reactor` se utiliza para crear un `Flux` a partir de una colección o
cualquier objeto que implemente la interfaz `Iterable`. A diferencia de `Flux.just()`, que solo emite una cantidad fija
y específica de elementos pasados como parámetros, `Flux.fromIterable()` se usa cuando ya tienes una colección de
elementos y deseas emitirlos como una secuencia de datos reactiva.

Este método puede manejar cualquier tipo de colección que implemente `Iterable`, lo que incluye estructuras como listas,
conjuntos, colas o cualquier clase personalizada que implemente dicha interfaz.

````java
public class Lec03FluxFromIterableOrArray {
    public static void main(String[] args) {
        List<String> letters = List.of("a", "b", "c", "d");
        Flux<String> stringFlux = Flux.fromIterable(letters);
        stringFlux.subscribe(Util.subscriber());

        Integer[] numbers = {1, 2, 3, 4};
        Flux<Integer> integerFlux = Flux.fromArray(numbers);
        integerFlux.subscribe(Util.subscriber());
    }
}
````

`Flux.fromArray()` es un método en `Project Reactor` que se utiliza para crear un `Flux` a partir de un arreglo
`(array)`. Este método es útil cuando ya tienes los elementos almacenados en un arreglo y quieres emitirlos como una
secuencia reactiva. Al igual que `Flux.fromIterable()`, `Flux.fromArray()` toma una fuente existente de datos, pero
en este caso, la fuente es un arreglo.

## Flux - From Stream

Permite crear un `Flux` a partir de un Stream de Java. Esto es especialmente útil cuando tienes un flujo de datos que
proviene de una fuente de datos que produce un Stream, como una lista, un archivo, o cualquier otra estructura que
soporte operaciones de tipo streaming.

El `Stream` en `Java` es una secuencia de elementos que se puede procesar de manera funcional, pero una vez consumido,
no puede ser reutilizado. A través de `Flux.fromStream()`, puedes convertir este flujo en una secuencia reactiva para
aprovechar la programación reactiva.

Los `Streams` en `Java` no se pueden reutilizar una vez consumidos. Por lo tanto, si intentas subscribirte varias veces
a un `Flux` creado con `Flux.fromStream()`, recibirás una excepción de tipo `IllegalStateException`, ya que el `Stream`
ya ha sido cerrado. Para evitar esto, puedes utilizar un `stream supplier` (proveedor de streams) que genere un
nuevo `Stream` cada vez que se realice una suscripción.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {

        List<Integer> numbers = List.of(1, 2, 3, 4);
        Stream<Integer> integerStream = numbers.stream();

        // El stream de java es de un solo uso, eso significa que si por ejemplo, consumo el stream en este
        // forEach, cuando siga al siguiente paso que es el uso del Flux me lanzará un error diciendo:
        // "El stream ya ha sido intervenido o cerrado."
        //
        // stream.forEach(System.out::println);

        Flux<Integer> integerFlux = Flux.fromStream(integerStream);
        integerFlux.subscribe(Util.subscriber());

        // Pero si queremos que varios subscriptores consuman el flujo, para evitar el error que se menciona
        // anteriormente, se podría usar el supplier del sream en el método .fromStream() colocándolo de esta
        // manera () -> letters.stream()
        List<String> letters = List.of("a", "b", "c");
        Flux<String> stringFlux = Flux.fromStream(letters::stream); //() -> letters.stream()
        stringFlux.subscribe(Util.subscriber("sub1"));
        stringFlux.subscribe(Util.subscriber("sub2"));
    }
}
````

## Flux Range

`Flux.range(int start, int count)`, permite crear un Flux que emite una secuencia de números enteros consecutivos
dentro de un rango definido. Es útil cuando necesitas generar secuencias de números de manera programática, ya sea para
realizar cálculos, pruebas o iteraciones controladas.

- `start`: Es el valor inicial que el `Flux` comenzará a emitir.
- `count`: Es la cantidad de números que se emitirán, comenzando desde `start`.

````java
public class Lec05FluxRange {
    public static void main(String[] args) {
        Flux<Integer> range = Flux.range(1, 10);
        range.subscribe(Util.subscriber());

        // Generamos 10 nombres aleatorios usando la librería Faker
        Flux<String> names = Flux.range(1, 10)
                .map(value -> Util.faker().name().firstName());
        names.subscribe(Util.subscriber());
    }
}
````
